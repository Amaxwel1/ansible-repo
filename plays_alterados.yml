---
- hosts: all
  gather_facts: no
  become: yes
  become_user: root

  vars:
    certificate_name: ""
    mount_cifs: ""
    mount_path: "/opt/ansiblefiles/files/cer"
    certificate_temp_folder: "/opt/ansiblefiles/files"

    create_pfx: true
    export_password: ""

    ritm_code: ""

    send_mail_cifs: producao
    send_mail_cifs_path: "/Ansible/mail_attachments/"
    send_mail_cifs_address:
      producao: "//AG-MZ-IW-FS-002.corp.bradesco.com.br/Apps"
      tutihofix: "//AG-AH-VV-FS-001.agorasenior.corp/Apps"

    _cred_file: "{{ certificate_temp_folder }}/ansible-autentication-cifs-{{ awx_job_id | default('local') }}"

  tasks:
    - name: Fluxo completo (validações + PFX opcional)
      block:
        - name: Verifica variáveis obrigatórias
          ansible.builtin.assert:
            that:
              - certificate_name | length > 0
              - mount_cifs | length > 0
              - (create_pfx | bool) implies (export_password | length > 0)
            fail_msg: >
              certificate_name e mount_cifs são obrigatórios.
              Se create_pfx = true é preciso definir export_password.

        - name: Garante diretório de montagem
          ansible.builtin.file:
            path: "{{ mount_path }}"
            state: directory

        - name: Cria arquivo de credencial CIFS
          ansible.builtin.copy:
            dest: "{{ _cred_file }}"
            content: "{{ ansible_password }}"
          delegate_to: localhost

        - name: Monta CIFS
          ansible.builtin.shell: |
            mount "{{ mount_cifs | lower }}" "{{ mount_path }}" \
              -o username={{ ansible_user }},password=`cat {{ _cred_file }}`,domain=agorasenior.corp,rw,vers=3.0
          args:
            warn: false

        - name: Define paths dos artefatos
          ansible.builtin.set_fact:
            cert_dir: "{{ mount_path }}/{{ certificate_name }}"
            key_path: "{{ cert_dir }}/{{ certificate_name }}.key"
            csr_path: "{{ cert_dir }}/{{ certificate_name }}.csr"
            cer_path: "{{ cert_dir }}/{{ certificate_name }}.cer"

        - name: Verifica presença de key/csr/cer
          ansible.builtin.stat:
            path: "{{ item }}"
          loop:
            - "{{ key_path }}"
            - "{{ csr_path }}"
            - "{{ cer_path }}"
          register: file_checks

        - name: Falha se arquivo obrigatório ausente
          ansible.builtin.fail:
            msg: "Arquivo obrigatório {{ item.stat.path }} ausente."
          when: not item.stat.exists
          loop: "{{ file_checks.results }}"

        - name: Extrai texto do CSR
          ansible.builtin.shell: "openssl req -in '{{ csr_path }}' -noout -text"
          register: csr_text

        - name: Extrai texto do CER
          ansible.builtin.shell: "openssl x509 -in '{{ cer_path }}' -noout -text"
          register: cer_text

        - name: Compara SUBJECT
          ansible.builtin.assert:
            that:
              - (csr_text.stdout | regex_search('Subject: (.*)')) ==
                (cer_text.stdout | regex_search('Subject: (.*)'))
            fail_msg: "Subject divergente entre CSR e CER"
            success_msg: "Subject OK"

        - name: Extrai SANs do CSR
          ansible.builtin.shell: |
            openssl req -in "{{ csr_path }}" -noout -text |
            awk '/X509v3 Subject Alternative Name/ {getline; print}' |
            sed 's/DNS://g; s/, /,/g'
          register: csr_sans_raw
          failed_when: false

        - name: Extrai SANs do CER
          ansible.builtin.shell: |
            openssl x509 -in "{{ cer_path }}" -noout -text |
            awk '/X509v3 Subject Alternative Name/ {getline; print}' |
            sed 's/DNS://g; s/, /,/g'
          register: cer_sans_raw
          failed_when: false

        - name: Compara SANs
          ansible.builtin.assert:
            that:
              - (csr_sans_raw.stdout.split(',') | reject('equalto','') | list | sort) ==
                (cer_sans_raw.stdout.split(',') | reject('equalto','') | list | sort)
            fail_msg: "SANs divergentes"
            success_msg: "SANs OK"
          when: csr_sans_raw.stdout | length > 0

        - name: Calcula modulus da KEY
          ansible.builtin.shell: "openssl rsa -in '{{ key_path }}' -noout -modulus | md5sum"
          register: key_mod

        - name: Calcula modulus do CER
          ansible.builtin.shell: "openssl x509 -in '{{ cer_path }}' -noout -modulus | md5sum"
          register: cer_mod

        - name: Compara modulus
          ansible.builtin.assert:
            that:
              - key_mod.stdout == cer_mod.stdout
            fail_msg: ".key NÃO corresponde ao .cer"
            success_msg: "Key × Cert OK"

        - name: Localiza CADEIA*.zip
          ansible.builtin.find:
            paths: "{{ cert_dir }}"
            patterns: "CADEIA*.zip"
            recurse: false
          register: ca_zips

        - name: Falha se não achar ZIP da cadeia
          ansible.builtin.fail:
            msg: "CADEIA*.zip não encontrado."
          when: ca_zips.files | length == 0

        - name: Descompacta cadeia
          ansible.builtin.unarchive:
            src: "{{ item.path }}"
            dest: "{{ cert_dir }}/_ca"
            remote_src: yes
          loop: "{{ ca_zips.files }}"

        - name: Concatena arquivos da CA (ignora diretórios) # FIX
          ansible.builtin.shell: |
            find "{{ cert_dir }}/_ca" -type f \( -iname "*.crt" -o -iname "*.cer" \) -print0 |
            xargs -0 cat > "{{ cert_dir }}/{{ certificate_name }}.ca"
          args:
            warn: false

        - name: Verifica cadeia com openssl verify
          ansible.builtin.shell: |
            openssl verify -CAfile "{{ cert_dir }}/{{ certificate_name }}.ca" "{{ cer_path }}"
          register: chain_verify
          failed_when: "'OK' not in chain_verify.stdout"

        - name: Gera .pfx (se create_pfx = true)
          block:
            - name: Executa openssl pkcs12 -export
              ansible.builtin.expect:
                command: >
                  openssl pkcs12 -export
                  -in "{{ cer_path }}"
                  -inkey "{{ key_path }}"
                  -chain -CAfile "{{ cert_dir }}/{{ certificate_name }}.ca"
                  -out "{{ cert_dir }}/{{ certificate_name }}.pfx"
                responses:
                  "Enter Export Password:": "{{ export_password }}"
                  "Verifying - Enter Export Password:": "{{ export_password }}"

            - name: Ajusta permissão do .pfx
              ansible.builtin.file:
                path: "{{ cert_dir }}/{{ certificate_name }}.pfx"
                mode: "0644"
          when: create_pfx | bool

        - name: Define corpo e assunto do e-mail
          ansible.builtin.set_stats:
            data:
              send_mail_body: |
                {{ 'Arquivo .pfx criado e ' if create_pfx | bool else '' }}certificado <b>{{ certificate_name }}</b> validado com sucesso.<br/>
                {% if ritm_code | length > 0 %}{{ ritm_code }}<br/>{% endif %}
                - Subject OK<br/>
                - SANs OK<br/>
                - Key × Cert OK<br/>
                - Cadeia OK<br/>
              send_mail_subject: "Ansible-Report - Certificate - Job #{{ awx_job_id }} - {{ awx_job_template_name }}"
              send_mail_attachments: |
                {{ [ cert_dir ~ '/' ~ certificate_name ~ '.pfx' ] if create_pfx | bool else [] }}
              send_mail_cifs: "{{ send_mail_cifs }}"

      always:
        - name: Remove diretório _ca extraído
          ansible.builtin.file:
            path: "{{ cert_dir }}/_ca"
            state: absent
          ignore_errors: true

        - name: Remove .ca concatenado
          ansible.builtin.file:
            path: "{{ cert_dir }}/{{ certificate_name }}.ca"
            state: absent
          ignore_errors: true

        - name: Desmonta CIFS
          ansible.builtin.command: "umount '{{ mount_path }}'"
          ignore_errors: true

        - name: Remove credencial CIFS
          ansible.builtin.file:
            path: "{{ _cred_file }}"
            state: absent
          delegate_to: localhost
          ignore_errors: true
